%Conclusión: Reflexión final sobre los alcances del trabajo práctico, la programación vectorial a bajo nivel, problemáticas encontradas, y todo lo que consideren pertinente.

\par La primera problemática encontrada fue identificar en qué casos se puede paralelizar el procesamiento y en cuáles no. Notamos que solo es posible utilizar instrucciones vectoriales cuando los datos están ubicados en forma contigua en memoria. Dada una matriz de datos cuyas filas se encuentran almacenadas en forma secuencial y contigua en memoria, se puede paralelizar el proceso si recorremos la matriz en forma horizontal (i.e. fila a fila) pero no en forma vertical (i.e. columna a columna).\newline
\par En la función solver\_lin\_solve la paralelización de los cálculos implicó realizar las operaciones matemáticas en distinto orden y esto trajo aparejada una diferencia en los resultados de ambas implementaciones, debida al redondeo propio de la representación numérica de punto flotante. Consideremos cuatro matrices del mismo tamaño: dos matrices $p_{ASM}$ y $p_C$ inicializadas con los mismos valores y otras dos matrices $div_{ASM}$ y $div_C$ también inicializadas con los mismos valores. Luego apliquemos la implementación en C de solver\_lin\_solve a las matrices con subíndice C y la implementación en ensamblador a las matrices con subíndice ASM. El módulo de la diferencia de cada uno de los valores finales de las matrices $p$ y $div$ fue siempre menor que $10^{-4}$ en las pruebas realizadas. La conversión de los valores numéricos expresados en punto flotante de precisión simple a precisión doble antes de realizar las operaciones matemáticas no aportó una reducción visible de esta diferencia.\newline
\par Notamos que la utilización de registros vectoriales permite reducir drásticamente la cantidad de accesos a memoria necesarios, lo cual, como vimos en la introducción, tiene un impacto serio en la performance de los programas. Por ejemplo, en la implementación en lenguaje ensamblador de solver\_lin\_solve logramos reducir los accesos a memoria a cinco por cada cuatro celdas procesadas. Suponemos que la implementación en lenguaje C hace más accesos a memoria mirando la programación.\newline
\par En un análisis de los gráficos de resultados, se puede observar que, a pesar de la variación del tamaño de las entradas, la proporción de ciclos de reloj se mantiene constante entre las implementaciones de C y ensamblador, siendo siempre menor la medición de las implementaciones en ensamblador.\newline
\par En la función solver\_set\_bnd se observó gran diferencia en gastos temporales, la implementación C gastó alrededor de cinco veces el tiempo gastado por la implementación en ASM.\newline
\par En la función solver\_lin\_solve se observó marcada diferencia en tiempo de ejecución, código C gastó alrededor del doble de tiempo que código ASM. Suponemos que la llamada a otra función influencia en la disminución de diferencia de tiempos, menor diferencia comparada a lo obtenido en función solver set bnd.\newline
\par En la función solver\_project se observó poca diferencia en tiempos de ejecución, implementación C gastó alrededor de un tercio de tiempo que código ASM.