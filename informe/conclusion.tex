%Conclusión: Reflexión final sobre los alcances del trabajo práctico, la programación vectorial a bajo nivel, problemáticas encontradas, y todo lo que consideren pertinente.

\par La primera problemática encontrada fue identificar en qué casos se puede paralelizar el procesamiento y en cuáles no. Notamos que es posible aprovechar instrucciones vectoriales cuando los datos están ubicados en forma contigua en memoria tal que en un fetch levantamos varios datos, evitando múltiples accesos a memoria. También concluímos que no siempre se puede obtener resultados en paralelo con vectores. Si el cálculo es secuencial, disminuye el rendimiento del programa, dado que en ese caso no pudimos paralelizar la operación, al necesitar para cada operación el resultado de la anterior.

No es lo mismo una implementación en C que una adaptación a lenguaje ASM. La conversión de los valores numéricos expresados en punto flotante de precisión simple a precisión doble antes de realizar las operaciones matemáticas no aportó una reducción visible de esta diferencia. El módulo de la diferencia de cada uno de los resultados obtenidos por implementación ASM y C fue siempre menor que $10^{-4}$ en las pruebas realizadas.%


\par En un análisis de los gráficos de resultados, se puede observar que, a pesar de la variación del tamaño de las entradas, la proporción de ciclos de reloj se mantiene constante entre las implementaciones de C y ensamblador, siendo siempre menor la medición de las implementaciones en ensamblador.%\newline

\par Por otra parte las optimizaciones de compilador, opción $o1$ y $o3$, no demostraron cambios notables en los resultados respecto a compilar con opción $o0$.

\par 
Notamos que uno de los principales beneficios de implementar nuestro codigo en Assembler en lugar de hacerlo en C, es la posibilidad de paralelizar operaciones mediante instrucciones SIMD.
En ese sentido, el primer desafío que nos encontramos al hacer este trabajo, fue intentar hacer uso de estas instrucciones siempre que sea conveniente, de manera de agilizar la ejecución de nuestro código lo más posible.

Esto lo pudimos llevar a cabo especialmente al trabajar con vectores, ya que al ubicarse en posiciones de memoria contiguas, en cada fetch podíamos leer y procesar más de una posicion de memoria por acceso a la misma. De otra manera, hubiera sido inevitable tener un acceso a memoria por cada operación. Fue en estas operaciones donde pudimos sacarle mayor jugo al uso de este tipo de instrucciones.

Por otro lado, también nos encontramos con situaciones donde no nos resultaba conveniente su uso, las operaciones secuenciales.
En estos casos necesitabamos para cada operación un resultado proveniente de una operación previa, lo que nos impedía implementarlas de forma paralelizada. En este caso no tenía sentido utilizar operaciones SIMD.

\par
Nuestro objetivo era comparar los rendimientos del mismo programa implementado en C  y en Assembler.
Al convertir floats de precisión simple a doble antes de llevar a cabo operaciones matemáticas.
Para medir esto, decidimos tomar como medida el módulo de la diferencia de cada uno de los resultados obtenidos en C y Assembler, y en todos los casos obvervamos una diferencia de al menos $10^{-4}$. Esto no nos pareció una diferencia muy considerable, sin embargo no estamos del todo convencidos de la verosimilutud de esta concluisión, al basarse en muestras relativamente reducidas. Con muestras más amplias, podríamos sacar una conclusión más segura.
