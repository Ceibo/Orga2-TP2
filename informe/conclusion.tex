%Conclusión: Reflexión final sobre los alcances del trabajo práctico, la programación vectorial a bajo nivel, problemáticas encontradas, y todo lo que consideren pertinente.

\par La primera problemática encontrada fue identificar en qué casos se puede paralelizar el procesamiento y en cuáles no. Notamos que es posible aprovechar instrucciones vectoriales cuando los datos están ubicados en forma contigua en memoria tal que en un fetch levantamos varios datos, evitando múltiples accesos a memoria. También concluímos que no siempre se puede obtener resultados en paralelo con vectores. Si el cálculo de un valor depende de el resultado de sus vecinos, en el vector, entonces disminuye el rendimiento de instrucciones SIMD.
%Dada una matriz de datos cuyas filas se encuentran almacenadas en forma secuencial y contigua en memoria, se puede paralelizar el proceso si recorremos la matriz en forma horizontal (i.e. recorriendo filas) pero no en forma vertical (i.e. recorriendo columnas).\newline
%\par En la función $Solver Lin Solve$ la paralelización de los cálculos implicó realizar las operaciones matemáticas en distinto orden y esto trajo aparejada una diferencia en los resultados de ambas implementaciones, debida al redondeo propio de la representación numérica de punto flotante. Consideremos cuatro matrices del mismo tamaño: dos matrices $p_{ASM}$ y $p_C$ inicializadas con los mismos valores y otras dos matrices $div_{ASM}$ y $div_C$ también inicializadas con los mismos valores. Luego apliquemos la implementación en C de $Solver Lin Solve$ a las matrices con subíndice C y la implementación en ensamblador a las matrices con subíndice ASM. El módulo de la diferencia de cada uno de los valores finales de las matrices $p$ y $div$ fue siempre menor que $10^{-4}$ en las pruebas realizadas. La conversión de los valores numéricos expresados en punto flotante de precisión simple a precisión doble antes de realizar las operaciones matemáticas no aportó una reducción visible de esta diferencia.

%\newline 
No es lo mismo una implementación en C que una adaptación a lenguaje ASM. La conversión de los valores numéricos expresados en punto flotante de precisión simple a precisión doble antes de realizar las operaciones matemáticas no aportó una reducción visible de esta diferencia. El módulo de la diferencia de cada uno de los resultados obtenidos por implementación ASM y C fue siempre menor que $10^{-4}$ en las pruebas realizadas.%\newline


%\par Notamos que la utilización de registros vectoriales permite reducir drásticamente la cantidad de accesos a memoria necesarios, lo cual, como vimos en la introducción, tiene un impacto serio en la performance de los programas. Por ejemplo, en la implementación en lenguaje ensamblador de $Solver Lin Solve$ logramos reducir los accesos a memoria a cinco por cada cuatro celdas procesadas. Suponemos que la implementación en lenguaje C hace más accesos a memoria mirando la programación.\newline
\par En un análisis de los gráficos de resultados, se puede observar que, a pesar de la variación del tamaño de las entradas, la proporción de ciclos de reloj se mantiene constante entre las implementaciones de C y ensamblador, siendo siempre menor la medición de las implementaciones en ensamblador.%\newline

\par Por otra parte las optimizaciones de compilador, opción $o1$ y $o3$, no demostraron cambios notables en los resultados respecto a compilar con opción $o0$.
