El código fuente de la simulación está escrito en lenguaje C y el compilador utilizado es GCC. Para las funciones de C \textit{solver\_lin\_solve}, \textit{solver\_set\_bnd} y \textit{solver\_project} hicimos implementaciones alternativas escritas en el lenguaje ensamblador de la familia de procesadores Intel x86-64. Las instrucciones vectoriales en lenguaje ensamblador utilizan registros de 128 bits. Los estados de la simulación se representan mediante matrices de números decimales de punto flotante de precisión simple (32 bits). Los algoritmos asumen que todas las matrices en una ejecución particular constan de $n\ +\ 2$ filas y $n\ +\ 2$ columnas con $n\ \geq\ 4$ y $n$ múltiplo de 4. A continuación se explica la implementación en ensamblador de las tres funciones.
\subsection{Función solver\_lin\_solve}
El ciclo principal está formado por dos ciclos: un ciclo que recorre las columnas de las matrices y
 otro ciclo que recorre las filas. A causa de que las matrices contienen dimensiones múltiplos de 
 cuatro, sin contar con las filas y columnas borde que no se usan en esta función, y los elementos
 de las matrices ocupan 4 bytes hemos decidido fetchear de a cuatro elementos consecutivos
 de una fila, fetchear es cargar de memoria, para aprovechar el espacio de los registros $xmm$, que es
 de 16 bytes y por lo tanto podemos cargar 4 elementos en un solo fetch. Así el índice de
 las columnas se incrementa de a 4, en un rango entre 1 y $N/4$. El ciclo sobre columnas es el primero.  
 Adentro tenemos otro ciclo donde se recorren las filas de a una. 

Empezamos cargando de matriz $x$.
 En cada iteración sobre fila se chequea si la fila es la primera, tal que si es así entonces 
 se realiza $1er$ fetch de 4 elementos consecutivos en un $xmm$ llamado $xmm\_piso$. Si no es la 
 primera entonces se copian de un registro $xmm$, llamado $xmm\_backup$, que contiene los 
 resultados de ciclo anterior.
Luego realizamos $2do$ fetch de a 4 de una fila siguiente, en un $xmm$ llamado
 $xmm\_left$ y avanzamos 2 posiciones para un $3er$ fetch de a 4 en un $xmm$ llamado $xmm\_medio\_y\_right$.
 En la siguiente fila fetcheamos de a 4 en un $xmm$ llamado $xmm\_techo$. Los elementos cargados desde $x$
 forman un bloque de elementos (ver figura) de donde vamos a obtener 4 resultados a partir de 6 
 accesos a memoria.
 Por otra parte de matriz $x0$ fetcheamos 4 elementos consecutivos en un $xmm$ llamado $xmm\_x0$.

 Una vez que tenemos los datos desempaquetamos con instrucción $cvtps2pd$, que convierte los single
 en parte baja de $xmm$ fuente a double en $xmm$ destino. Luego shifteamos a derecha con $psrldq$ para
 acceder a los single de parte alta de los $xmm$ y convertirlos a double. En este paso obtenemos 
 $xmm\_piso\_low$ y $xmm\_piso\_high$ que corresponden a desempacar a double los 2 single en parte baja y los 
 2 single en parte alta de $xmm\_piso$ respectivamente.
Repetimos este procedimiento con $xmm\_medio\_y\_right$ obteniendo 
 $xmm\_medio\_y\_right\_low$ y $xmm\_medio\_y\_right\_high$. De misma manera desempaquetamos 
 $xmm\_techo$ en $xmm\_techo\_low$ y $xmm\_techo\_high$.
 Por otra parte se convierten los singles $a$ y $c$ a double en $xmm\_a$ y $xmm\_b$ con instrucción
 $cvtss2sd$, que convierte escalar single de parte menos significativa de $xmm$ fuente a
 escalar double en parte baja de $xmm$ destino. 
 Por último convertimos los single de $xmm\_x0$ usando instrucción $cvtps2pd$ en double obteniendo 2 
 $xmm$: $xmm\_x0\_low$ y $xmm\_x0\_high$. También convertimos primer single en $xmm\_left$ a double con instrucción $cvtss2sd$ que convierte single
 de parte menos significativa de $xmm$ fuente a double en parte baja de $xmm$ destino. Se guarda esto en
 $xmm\_res$, que usaremos como contenedor de resultados finales.

Siguiente paso se suman los 2 double de $xmm\_techo\_low$ y $xmm\_medio\_y\_right\_low$ guardándose en un $ xmm$. 
Luego a estos 2 doubles resultado de suma entre techo y lado derecho les sumamos los 2 doubles
 en $xmm\_piso\_low$ obteniendo sumas parciales $x[IX(i+1,j)]+x[IX(i,j-1)]+x[IX(i,j+1)]$ de 2 puntos de $x$.
 Guardamos esto en $xmm$ llamado $xmm\_sum\_parcial\_low$ y repetimos procedimiento con los $xmm$
 de partes altas: $xmm\_techo\_high$, $xmm\_piso\_high$ y $xmm\_medio\_y\_right\_high$. Guardamos
 estos resultados en $xmm\_sum\_parcial\_high$ asociados a otros 2 puntos de $x$.

   Paso siguiente entramos en ciclo que se repite
 4 veces operando sobre doubles de parte baja y obteniendo en cada iteración un resultado a guardar 
 en matriz $x$. Primero se suman escalar de $xmm\_res$ con con double en parte baja de 
 alguno de los $xmm\_sum\_parcial$ con instrucción $addsd$ que suma 2 escalares doubles, obteniéndose 
  $x[IX(i-1,j)]+x[IX(i+1,j)]+x[IX(i,j-1)]+x[IX(i,j+1)]$, y guardándose en $xmm\_res$. Entonces se
 multiplica con escalar $xmm\_a$ usando instrucción $mulsd$, que multiplica 2 escalares double,
 obteniéndose $a*(x[IX(i-1,j)]+x[IX(i+1,j)]+x[IX(i,j-1)]+x[IX(i,j+1)]) $ y lo guardamos en $xmm\_res$.
Luego a $xmm\_res$ le sumamos double en parte baja de $xmm\_x0$ obteniendo 
 $x0[IX(i,j)] + a*(x[IX(i-1,j)]+x[IX(i+1,j)]+x[IX(i,j-1)]+x[IX(i,j+1)])$ y lo guardamos en $xmm\_res$.
 Paso seguido dividimos $xmm\_res$ por escalar $xmm\_c$ con instrucción $divsd$, que divide escalares
 double, obteniendo double $(x0[IX(i,j)] + a*(x[IX(i-1,j)]+x[IX(i+1,j)]+x[IX(i,j-1)]+x[IX(i,j+1)]))/c$
 y lo guardamos en $xmm\_res$. De esta forma se respeta el código $c$, en donde sobre una fila de $x$ los 
 puntos se actualizan hacia derecha, es decir que dependen de sus vecinos izquierdos, ya que en la 
 primera de estas 4 iteraciones se usa $xmm\_res$ cargado desde $x$ pero en las siguientes $xmm\_res$ está
 cargado con valor obtenido en anterior iteración. Finalmente convertimos el resultado en $xmm\_res$ 
 de double a single con instrucción $cvtsd2ss$ y lo movemos a $xmm\_backup$ con instrucción $movss$, que
 mueve un escalar single a parte baja de $xmm$ destino. 
Una vez guardado resultado en $xmm\_backup$ shifteamos este registro a izquierda con instrucción
 $pslldq$, que mueve a derecha una double quadword, moviendo de a 4 bytes el valor recientemente
 cargado. De esta manera dejamos espacio para un single en parte baja de $xmm\_backup$ que recibirá a 
 próximo resultado desde $xmm\_res$. En cada iteración de este ciclo shifteamos los registros 
 $xmm\_sum\_parcial\_low$ y $xmm\_x0\_low$ a derecha, con $psrldq$, para acceder a las partes altas de estos y, en caso de haber usado los 2 doubles de cada registro pasamos a operar con los $xmm\_sum\_parcial\_high$ y 
 $xmm\_x0\_high$.

Luego de salir de este ciclo de 4 iteraciones tenemos en $xmm\_backup$ los 4 resultados a subir en 
 matriz $x$ pero con las posiciones invertidas por como se cargaron en las iteraciones. Entonces
 intercambiamos sus posiciones con instrucción $pshufd$ que reubica doublewords en destino con 
 ayuda de un registro temporal. Una vez hecho esto guardamos estos 4 resultados en matriz $x$ y 
 saltamos a siguiente fila terminando una iteración de ciclo sobre filas. En próxima iteración
 no tenemos que cargar de memoria los 4 resultados obtenidos, ya que los tenemos guardados en
 $xmm\_backup$, que sobreescribieron fila de $x$ y son requeridos.
 Al iterar sobre $N$ filas terminamos una iteración de ciclo sobre columnas y avanzamos a las 
 siguientes 4 columnas de $x$ y $x0$. Una vez iterado $N/4$ veces ciclo principal salimos de este con bloque de 
 $N\times N$ de $x$ actualizado.

\subsection{Función solver\_set\_bnd}
La función solver\_set\_bnd se encarga de actualizar los valores del borde.
\par El algoritmo consta de tres partes: el procesamiento de los bordes horizontales (la primera y la última fila de la matriz), el procesamiento de los bordes verticales (la primera y la última columa) y el procesamiento de las esquinas. Los primeros dos se realizan en un ciclo.
\par El procesamiento horizontal consiste en sobreescribir las celdas de las filas $0$ y $n\ +\ 1$ con las filas $1$ y $n$ respectivamente. En algunos casos el valor de la celda se invierte antes de la escritura, según los datos de entrada (para más información consulte el código fuente). La lectura, escritura y cambio de signo se realiza de a $4$ elementos con un registro vectorial, ya que las celdas de cada fila se encuentran contiguas en memoria. El procesamiento excluye a la primera y última celda de las filas involucradas.
\par El procesamiento vertical es similar al horizontal porque también consiste en sobreescribir respectivamente las columnas $0$ y $n\ +\ 1$ con las columnas $1$ y $n$ excluyendo la primera y la última celda de las columnas. Como sucede en el procesamiento de las filas, en algunos casos el valor de la celda se invierte antes de la escritura, según los datos de entrada. La diferencia es que solo el cambio de signo se realiza de a $4$ elementos con un registro vectorial; la lectura y escritura se realizan individualmente porque las celdas no se encuentran contiguas en memoria.
\par El procesamiento de las esquinas consiste en sumar el valor de las dos celdas contiguas a cada esquina (contiguas en la interpretación matricial, no en memoria), luego dividir por dos ese valor y escribirlo en la esquina más cercana a esas celdas. El resultado de este cálculo está determinado por la operación realizada anteriormente sobre las filas y columnas, por lo tanto podemos evitar los cálculos en pos de una mayor performance si consideramos dos casos, a saber: si hubo o no cambios de signo. El cambio de signo, como ya fue mencionado anteriormente, está determinado por los parámetros de entrada.
\par El primer caso se da cuando hay cambio de signo de algunos valores. El cambio de signo respeta la siguiente regla: si el signo de cada elemento de las filas fue cambiado, entonces el signo de cada celda de las columnas no cambió, y viceversa. En este caso el resultado de la cuenta da siempre cero, por lo cual el proceso consiste en la escritura de este valor en las cuatro esquinas.
\par En el segundo caso no hay cambio de signo de ninguna celda. En este caso las esquinas serán sobreescritas con el valor de cualquiera de las dos celdas contiguas \(no diagonales\) a ella, ya que ambas tendrán el mismo valor (y el resultado de la cuenta es este valor).
\subsection{Función solver\_project}
Lorem ipsum dolor sit amet.
