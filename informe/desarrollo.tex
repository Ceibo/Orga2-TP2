El código fuente de la simulación está escrito en lenguaje C y el compilador utilizado es GCC. Para las funciones de C \textit{solver\_lin\_solve}, \textit{solver\_set\_bnd} y \textit{solver\_project} hicimos implementaciones alternativas escritas en el lenguaje ensamblador de la familia de procesadores Intel x86-64. Las instrucciones vectoriales en lenguaje ensamblador utilizan registros de 128 bits. Los estados de la simulación se representan mediante matrices de números decimales de punto flotante de precisión simple (32 bits). Los algoritmos asumen que todas las matrices en una ejecución particular constan de $n\ +\ 2$ filas y $n\ +\ 2$ columnas con $n\ \geq\ 4$ y $n$ múltiplo de 4. A continuación se explica la implementación en ensamblador de las tres funciones.
\subsection{Función solver\_lin\_solve}
Lorem ipsum dolor sit amet.
\subsection{Función solver\_set\_bnd}
La función solver\_set\_bnd se encarga de actualizar los valores del borde.
\par El algoritmo consta de tres partes: el procesamiento de los bordes horizontales (la primera y la última fila de la matriz), el procesamiento de los bordes verticales (la primera y la última columa) y el procesamiento de las esquinas. Los primeros dos se realizan en un ciclo.
\par El procesamiento horizontal consiste en sobreescribir las celdas de las filas $0$ y $n\ +\ 1$ con las filas $1$ y $n$ respectivamente. En algunos casos el valor de la celda se invierte antes de la escritura, según los datos de entrada (para más información consulte el código fuente). La lectura, escritura y cambio de signo se realiza de a $4$ elementos con un registro vectorial, ya que las celdas de cada fila se encuentran contiguas en memoria. El procesamiento excluye a la primera y última celda de las filas involucradas.
\par El procesamiento vertical es similar al horizontal porque también consiste en sobreescribir respectivamente las columnas $0$ y $n\ +\ 1$ con las columnas $1$ y $n$ excluyendo la primera y la última celda de las columnas. Como sucede en el procesamiento de las filas, en algunos casos el valor de la celda se invierte antes de la escritura, según los datos de entrada. La diferencia es que solo el cambio de signo se realiza de a $4$ elementos con un registro vectorial; la lectura y escritura se realizan individualmente porque las celdas no se encuentran contiguas en memoria.
\par El procesamiento de las esquinas consiste en sumar el valor de las dos celdas contiguas a cada esquina (contiguas en la interpretación matricial, no en memoria), luego dividir por dos ese valor y escribirlo en la esquina más cercana a esas celdas. El resultado de este cálculo está determinado por la operación realizada anteriormente sobre las filas y columnas, por lo tanto podemos evitar los cálculos en pos de una mayor performance si consideramos dos casos, a saber: si hubo o no cambios de signo. El cambio de signo, como ya fue mencionado anteriormente, está determinado por los parámetros de entrada.
\par El primer caso se da cuando hay cambio de signo de algunos valores. El cambio de signo respeta la siguiente regla: si el signo de cada elemento de las filas fue cambiado, entonces el signo de cada celda de las columnas no cambió, y viceversa. En este caso el resultado de la cuenta da siempre cero, por lo cual el proceso consiste en la escritura de este valor en las cuatro esquinas.
\par En el segundo caso no hay cambio de signo de ninguna celda. En este caso las esquinas serán sobreescritas con el valor de cualquiera de las dos celdas contiguas \(no diagonales\) a ella, ya que ambas tendrán el mismo valor (y el resultado de la cuenta es este valor).
\subsection{Función solver\_project}
Lorem ipsum dolor sit amet.